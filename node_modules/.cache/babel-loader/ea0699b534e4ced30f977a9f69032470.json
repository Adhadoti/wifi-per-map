{"ast":null,"code":"import _classCallCheck from \"/Users/devon/Desktop/Spring_2023/Senior Project/map_gui-main/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/devon/Desktop/Spring_2023/Senior Project/map_gui-main/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/devon/Desktop/Spring_2023/Senior Project/map_gui-main/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/devon/Desktop/Spring_2023/Senior Project/map_gui-main/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/devon/Desktop/Spring_2023/Senior Project/map_gui-main/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport Input from './input';\nimport { INPUT_EVENT_TYPES } from '../constants';\nvar MOUSE_EVENTS = INPUT_EVENT_TYPES.MOUSE_EVENTS;\nvar MOVE_EVENT_TYPE = 'pointermove';\nvar OVER_EVENT_TYPE = 'pointerover';\nvar OUT_EVENT_TYPE = 'pointerout';\nvar ENTER_EVENT_TYPE = 'pointerenter';\nvar LEAVE_EVENT_TYPE = 'pointerleave';\n/**\n * Hammer.js swallows 'move' events (for pointer/touch/mouse)\n * when the pointer is not down. This class sets up a handler\n * specifically for these events to work around this limitation.\n * Note that this could be extended to more intelligently handle\n * move events across input types, e.g. storing multiple simultaneous\n * pointer/touch events, calculating speed/direction, etc.\n */\n\nvar MoveInput = /*#__PURE__*/function (_Input) {\n  _inherits(MoveInput, _Input);\n\n  function MoveInput(element, callback, options) {\n    var _this;\n\n    _classCallCheck(this, MoveInput);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MoveInput).call(this, element, callback, options));\n\n    _this.handleEvent = function (event) {\n      _this.handleOverEvent(event);\n\n      _this.handleOutEvent(event);\n\n      _this.handleEnterEvent(event);\n\n      _this.handleLeaveEvent(event);\n\n      _this.handleMoveEvent(event);\n    };\n\n    _this.pressed = false;\n    var enable = _this.options.enable;\n    _this.enableMoveEvent = enable;\n    _this.enableLeaveEvent = enable;\n    _this.enableEnterEvent = enable;\n    _this.enableOutEvent = enable;\n    _this.enableOverEvent = enable;\n    _this.events = (_this.options.events || []).concat(MOUSE_EVENTS);\n\n    _this.events.forEach(function (event) {\n      return element.addEventListener(event, _this.handleEvent);\n    });\n\n    return _this;\n  }\n\n  _createClass(MoveInput, [{\n    key: \"destroy\",\n    value: function destroy() {\n      var _this2 = this;\n\n      this.events.forEach(function (event) {\n        return _this2.element.removeEventListener(event, _this2.handleEvent);\n      });\n    }\n    /**\n     * Enable this input (begin processing events)\n     * if the specified event type is among those handled by this input.\n     */\n\n  }, {\n    key: \"enableEventType\",\n    value: function enableEventType(eventType, enabled) {\n      if (eventType === MOVE_EVENT_TYPE) {\n        this.enableMoveEvent = enabled;\n      }\n\n      if (eventType === OVER_EVENT_TYPE) {\n        this.enableOverEvent = enabled;\n      }\n\n      if (eventType === OUT_EVENT_TYPE) {\n        this.enableOutEvent = enabled;\n      }\n\n      if (eventType === ENTER_EVENT_TYPE) {\n        this.enableEnterEvent = enabled;\n      }\n\n      if (eventType === LEAVE_EVENT_TYPE) {\n        this.enableLeaveEvent = enabled;\n      }\n    }\n  }, {\n    key: \"handleOverEvent\",\n    value: function handleOverEvent(event) {\n      if (this.enableOverEvent) {\n        if (event.type === 'mouseover') {\n          this._emit(OVER_EVENT_TYPE, event);\n        }\n      }\n    }\n  }, {\n    key: \"handleOutEvent\",\n    value: function handleOutEvent(event) {\n      if (this.enableOutEvent) {\n        if (event.type === 'mouseout') {\n          this._emit(OUT_EVENT_TYPE, event);\n        }\n      }\n    }\n  }, {\n    key: \"handleEnterEvent\",\n    value: function handleEnterEvent(event) {\n      if (this.enableEnterEvent) {\n        if (event.type === 'mouseenter') {\n          this._emit(ENTER_EVENT_TYPE, event);\n        }\n      }\n    }\n  }, {\n    key: \"handleLeaveEvent\",\n    value: function handleLeaveEvent(event) {\n      if (this.enableLeaveEvent) {\n        if (event.type === 'mouseleave') {\n          this._emit(LEAVE_EVENT_TYPE, event);\n        }\n      }\n    }\n  }, {\n    key: \"handleMoveEvent\",\n    value: function handleMoveEvent(event) {\n      if (this.enableMoveEvent) {\n        switch (event.type) {\n          case 'mousedown':\n            if (event.button >= 0) {\n              // Button is down\n              this.pressed = true;\n            }\n\n            break;\n\n          case 'mousemove':\n            // Move events use `which` to track the button being pressed\n            if (event.which === 0) {\n              // Button is not down\n              this.pressed = false;\n            }\n\n            if (!this.pressed) {\n              // Drag events are emitted by hammer already\n              // we just need to emit the move event on hover\n              this._emit(MOVE_EVENT_TYPE, event);\n            }\n\n            break;\n\n          case 'mouseup':\n            this.pressed = false;\n            break;\n\n          default:\n        }\n      }\n    }\n  }, {\n    key: \"_emit\",\n    value: function _emit(type, event) {\n      this.callback({\n        type: type,\n        center: {\n          x: event.clientX,\n          y: event.clientY\n        },\n        srcEvent: event,\n        pointerType: 'mouse',\n        target: event.target\n      });\n    }\n  }]);\n\n  return MoveInput;\n}(Input);\n\nexport { MoveInput as default };","map":null,"metadata":{},"sourceType":"module"}